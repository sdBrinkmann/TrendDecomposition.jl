var documenterSearchIndex = {"docs":
[{"location":"man/penalized/#Penalized-Smoothing","page":"Penalized Smoothing","title":"Penalized Smoothing","text":"","category":"section"},{"location":"man/penalized/#Whittaker-Henderson-Smoothing","page":"Penalized Smoothing","title":"Whittaker-Henderson Smoothing","text":"","category":"section"},{"location":"man/penalized/#TrendDecomposition.bohlmannFilter","page":"Penalized Smoothing","title":"TrendDecomposition.bohlmannFilter","text":"bohlmannFilter(x :: Vector, m :: Int, λ :: Real)\n\nThis is the generalization of the Hodrick-Prescott filter, also known as Whittaker-Henderson smoothing, using the m-th difference to estimate the trend component.\n\n\n\n\n\n","category":"function"},{"location":"man/penalized/#Hodrick-Prescott-(HP)-Filter","page":"Penalized Smoothing","title":"Hodrick-Prescott (HP) Filter","text":"","category":"section"},{"location":"man/penalized/#TrendDecomposition.hpFilter","page":"Penalized Smoothing","title":"TrendDecomposition.hpFilter","text":"hpFilter(x::Vector, λ::Real)\n\nApply the Hodrick-Prescott decomposition to vector x with multiplier value λ.\n\nFunction returns the trend component.\n\n\n\n\n\nhpFilter(x::Vector, λ::Real, iter::Int)\n\nCompute boosted Hodrick-Prescott filter with number of iterations specified by iter.\n\nFunction returns the trend component.\n\n\n\n\n\n","category":"function"},{"location":"man/penalized/#Boosted-HP-Filter","page":"Penalized Smoothing","title":"Boosted HP Filter","text":"","category":"section"},{"location":"man/penalized/#TrendDecomposition.bhpFilter","page":"Penalized Smoothing","title":"TrendDecomposition.bhpFilter","text":"bhpFilter(x::Vector, λ::Real; Criterion=\"BIC\", max_iter::Int = 100, p::Float64=0.05)\n\nComputes the boosted Hodrick-Prescott filter by appyling the filter iterativly over the trend component with stop criterion being either a Bayesian-type information criterion (BIC) or an augmented Dickey-Fuller (ADF) test.\n\nFunction returns the trend component.\n\n\n\n\n\n","category":"function"},{"location":"man/start/#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"This package is now featured on the official general Julia package registry.  Simply use Julia's package manager pkg to add TrendDecomposition to your preferred environment.","category":"page"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"@(v1.11) pkg> add TrendDecomposition\n\njulia> using TrendDecomposition","category":"page"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"The developing branch of this package can either be employed  by cloning this repository or by using the Julia package manager. With the package manager simply use the add command:","category":"page"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"@(v1.11) pkg> add https://github.com/sdBrinkmann/TrendDecomposition.jl","category":"page"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"warning: Warning\nThis package is currently under rapid development and follows Semantic Versioning. Until the 1.0.0 release is reached, the API of this package can change with any minor version update,  please  consult the documentation of this package after each update when using this package.","category":"page"},{"location":"man/start/#Usage","page":"Get Started","title":"Usage","text":"","category":"section"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"The basic usage is demonstrated with the US industrial production index (IPI) provided by FRED data service.","category":"page"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"using TrendDecomposition\nusing CSV\n\n# Set path to directory where time series is located\npath = \"/.../data\"\n\nIPI = CSV.read(\"$(path)/IPB50001SQ.csv\", copycols=true)\n\n# HP filter with λ = 1600\nhp = hpFilter(IPI[!, 2], 1600)\n\n# The above is equivalent to Whittaker-Henderson smoothing with m = 2 differentiation\nwh = bohlmannFilter(IPI[!, 2], 2, 1600)\n\n# Boosted HP filter with baysian-type information criterion (BIC)\nbHP_bic = bhpFilter(IPI[!, 2], 1600, Criterion=\"BIC\")\n\n# Boosted HP filter with augmented Dickey-Fuller (ADF) test \nbHP_adf = bhpFilter(IPI[!, 2], 1600, Criterion=\"ADF\", p=0.01)","category":"page"},{"location":"man/start/","page":"Get Started","title":"Get Started","text":"(Image: HP Results)","category":"page"},{"location":"man/exponential/#Exponential-Smoothing","page":"Exponential Smoothing","title":"Exponential Smoothing","text":"","category":"section"},{"location":"man/exponential/","page":"Exponential Smoothing","title":"Exponential Smoothing","text":"Exponential smoothing also known as exponentially weighted moving average (EWMA)","category":"page"},{"location":"man/exponential/#Simple-exponential-smoothing","page":"Exponential Smoothing","title":"Simple exponential smoothing","text":"","category":"section"},{"location":"man/exponential/#TrendDecomposition.expSmoothing","page":"Exponential Smoothing","title":"TrendDecomposition.expSmoothing","text":"expSmoothing(y :: Vector, λ :: Real; startValue::Bool = true, v_0::Real = 0.0)\n\nSimple exponential smoothing with smoothing factor λ. If startValue equals true, v_0 will be used as initial value, otherwise the first element of y (y[1]) will be selected as starting value. Using y[1] as starting value will result in a different mathematical function.   \n\n\n\n\n\n","category":"function"},{"location":"man/exponential/#Double-exponential-smoothing","page":"Exponential Smoothing","title":"Double exponential smoothing","text":"","category":"section"},{"location":"man/exponential/#TrendDecomposition.brownLinear","page":"Exponential Smoothing","title":"TrendDecomposition.brownLinear","text":"brownLinear(y :: Vector, λ :: Real; h::Int = 0, startValues::Tuple=(), φ::Real = 1.0)\n\nDouble exponential smoothing with smoothing factor λ and damping factor φ (\u000barphi) given vector y (N x 1) and h forecast periods.\n\nStart values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.\n\nReturns a tuple with (f, D), where f is a (N+h) x 1 vector with the forecast values and D is a (N x 2) matrix with the level and slope as columns.\n\n\n\n\n\n","category":"function"},{"location":"man/exponential/#TrendDecomposition.holtLinear","page":"Exponential Smoothing","title":"TrendDecomposition.holtLinear","text":"holtLinear(y :: Vector, λ₁ :: Real, λ₂ :: Real;\n                startValues::Tuple=(), h::Int = 0, φ::Real = 1.0)\n\nHolt's linear trend method with smoothing factors λ₁ (level) and λ₂ (slope) and damping factor φ (\u000barphi) given vector y (N x 1) and h forecast periods.\n\nStart values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.\n\nReturns a tuple with (f, D), where f is a ((N+h) x 1) vector with the forecast values and D is a (N x 2) matrix with the level and slope as columns.\n\n\n\n\n\n","category":"function"},{"location":"man/exponential/#Holt-Winters-forecasting","page":"Exponential Smoothing","title":"Holt-Winters forecasting","text":"","category":"section"},{"location":"man/exponential/#TrendDecomposition.holtWinters","page":"Exponential Smoothing","title":"TrendDecomposition.holtWinters","text":"holtWinters(y :: Vector, λ₁ :: Real, λ₂ :: Real, λ₃ :: Real, s::Int;\n                 startValues::Tuple=(), h::Int = 0, model=:add, φ::Real = 1.0)\n\nHolt-Winters method with smoothing factors λ₁ (level), λ₂ (slope) and λ₃ (season) and damping factor φ (\u000barphi) given vector y (N x 1) and h forecast periods.\n\nStart values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.\n\nReturns a tuple with (f, D), where f is a ((N+h) x 1) vector with the forecast values and D is a (N x 3) matrix with the level, slope, season values as columns.\n\n\n\n\n\n","category":"function"},{"location":"man/moving/#Moving-Average-(MA)","page":"Moving Average","title":"Moving Average (MA)","text":"","category":"section"},{"location":"man/moving/#Rolling-Average","page":"Moving Average","title":"Rolling Average","text":"","category":"section"},{"location":"man/moving/#TrendDecomposition.rollingAverage","page":"Moving Average","title":"TrendDecomposition.rollingAverage","text":"rollingAverage(y :: Vector, p :: Int; centered::Bool = true, discard::Bool = false, offset::Int = 0)\n\nComputes the moving average of the vector y with p data points.\n\nWith centered equal true, p has to be an odd number so that an equal number of leads and lags can be used. By default when centered = false, the computation includes the datum plus its most recent p-1 lagged values. This behavior can be changed by including an offset; a positive offset includes one additonal lead at the expense of the oldest lag value\n\nFor discard=false the function rolls over all data, even if not all p data points can be used.\n\n\n\n\n\nrollingAverage(y :: Vector, p :: Int, weights :: Vector;\n    centered::Bool = true, discard::Bool = false, offset::Int = 0)\n\nComputes the moving average of the vector y with p data points weighted by vector w.\n\nWith centered equal true, p has to be an odd number so that an equal number of leads and lags can be used. By default when centered = false, the computation includes the datum plus its most recent p-1 lagged values. This behavior can be changed by including an offset; a positive offset includes one additonal lead at the expense of the oldest lag value.\n\nFor discard=false the function rolls over all data, even if not all p data points can be used, in any case all used weights will sum to 1.\n\n\n\n\n\n","category":"function"},{"location":"man/moving/#Seasonal-Average","page":"Moving Average","title":"Seasonal Average","text":"","category":"section"},{"location":"man/moving/#TrendDecomposition.maSeason","page":"Moving Average","title":"TrendDecomposition.maSeason","text":"maSeason(y :: Vector, seasons :: Int; repeating::Bool = false)\n\nGiven the number of seasons, the function computes the average value of each season component. This method works better for detrended data.\n\nWith repeating equal true the function will repeat the results until the output vector has the same length as the input vector y.\n\n\n\n\n\n","category":"function"},{"location":"man/moving/#MA-decomposition","page":"Moving Average","title":"MA decomposition","text":"","category":"section"},{"location":"man/moving/#TrendDecomposition.maDecompose","page":"Moving Average","title":"TrendDecomposition.maDecompose","text":"maDecompose(y :: Vector, seasons :: Int; combine::Bool = false, model=:add)\n\nDecomposes the time series y into trend (T), season (S) and noise components (I).\n\nEither assumes an additive model (:add) or a multiplicative model (:mul).\n\nReplicates the R decompose{stats} function. For a more generic function implementation see decompose of this package (TrendDecomposition.decompose).\n\nReturns a matrix where the columns correspont to the above mentioned components in (T, S, I) order; with combine equal true it returns (y, T, S, I) as columns.\n\n\n\n\n\n","category":"function"},{"location":"#TrendDecomposition.jl","page":"Introduction","title":"TrendDecomposition.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the TrendDecomposition.jl documentation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: Info\nThis is a preliminary version of the documentation. The package is also not feature complete until version 1.0, thus sometimes there are references to not yet implemented features such as forecasting.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TrendDecomposition.jl is a Julia package for decomposition of time series into trend and cycle components. More generally it provides  both (stochastic) trend component estimation and forecasting, though not all methods are suitable for forecasting.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By using filters and smoothers the most pragmatic approach to trend decomposition is estimating the trend t and defining the cyclical component c of time series y as c = y - t. Often it is up to the user of this module to calculate the cyclical components themselves with the computed trend returned from a function  provided by this module.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For now this package implements moving averages, simiple seaonal averages and based on that additive and multiplicative model decomposition. It also includes the Hodrick-Prescott (HP) filter as well as its generalization, generally known as Whittaker-Henderson smoothing, in this package named bohlmannFilter after its first inventor George Bohlmann.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition this module tries to implement also more novel approaches; so far the boosted HP Filter based  on Peter Phillips and Zhentao Shi (2019): \"Boosting the Hodrick-Prescott Filter\"  has been implemented.","category":"page"},{"location":"man/api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"","category":"page"}]
}
