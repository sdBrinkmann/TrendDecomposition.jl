<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exponential Smoothing · TrendDecomposition</title><meta name="title" content="Exponential Smoothing · TrendDecomposition"/><meta property="og:title" content="Exponential Smoothing · TrendDecomposition"/><meta property="twitter:title" content="Exponential Smoothing · TrendDecomposition"/><meta name="description" content="Documentation for TrendDecomposition."/><meta property="og:description" content="Documentation for TrendDecomposition."/><meta property="twitter:description" content="Documentation for TrendDecomposition."/><meta property="og:url" content="https://sdbrinkmann.github.io/TrendDecomposition.jl/stable/man/exponential/"/><meta property="twitter:url" content="https://sdbrinkmann.github.io/TrendDecomposition.jl/stable/man/exponential/"/><link rel="canonical" href="https://sdbrinkmann.github.io/TrendDecomposition.jl/stable/man/exponential/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TrendDecomposition</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../start/">Get Started</a></li><li><a class="tocitem" href="../moving/">Moving Average</a></li><li><a class="tocitem" href="../penalized/">Penalized Smoothing</a></li><li class="is-active"><a class="tocitem" href>Exponential Smoothing</a><ul class="internal"><li><a class="tocitem" href="#Simple-exponential-smoothing"><span>Simple exponential smoothing</span></a></li><li><a class="tocitem" href="#Holt&#39;s-procedure"><span>Holt&#39;s procedure</span></a></li><li><a class="tocitem" href="#Double-exponential-smoothing"><span>Double exponential smoothing</span></a></li><li><a class="tocitem" href="#Holt-Winters-forecasting"><span>Holt-Winters forecasting</span></a></li><li><a class="tocitem" href="#Optimization"><span>Optimization</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../api/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Exponential Smoothing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exponential Smoothing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sdBrinkmann/TrendDecomposition.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/master/docs/src/man/exponential.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exponential-Smoothing"><a class="docs-heading-anchor" href="#Exponential-Smoothing">Exponential Smoothing</a><a id="Exponential-Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-Smoothing" title="Permalink"></a></h1><p>Exponential smoothing, also known as exponentially weighted moving average (EWMA), allows us to model a time series as an additive or multiplicative composition, in order to conduct forecasts. Here in its additive form it can be written as </p><p class="math-container">\[	y_t = l_t + S_t + u_t,\]</p><p>where <span>$l$</span> denotes the level or trend component and <span>$S$</span> the seaonal component, the  latter component is only included in the Holt-Winters method.<sup class="footnote-reference"><a id="citeref-Winters60" href="#footnote-Winters60" class="footnote-ref">[Winters60]</a><span class="footnote-preview" id="fn-Winters60"></span></sup> </p><p>The residual or noise term <span>$u_t$</span> is implicitly assumed and the parameters of the  models down below are estimated by minimizing the squared residual terms, <span>$\^u_t = y_t - \^y_t$</span>,  summed over the entire time series. The model makes otherwise no assumptions and is stated in its classic recursive fashion.</p><h2 id="Simple-exponential-smoothing"><a class="docs-heading-anchor" href="#Simple-exponential-smoothing">Simple exponential smoothing</a><a id="Simple-exponential-smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-exponential-smoothing" title="Permalink"></a></h2><p>Simple exponential smoothing is a special case of weighted moving averages, where weights decline exponentially. Implemented as a recursion it is know as  exponentially weighted moving average (EWMA) defined as:</p><p class="math-container">\[    l_t = (1-\lambda) * l_{t-1} + \lambda * y_t\]</p><p>For the recursion to work a start value has to be defined. Given that the time series <span>$y_t$</span> is recorded for <span>$t = 1,...,T$</span>, a start value <span>$y_0$</span> has to be selected.</p><article><details class="docstring" open="true"><summary id="TrendDecomposition.expSmoothing"><a class="docstring-binding" href="#TrendDecomposition.expSmoothing"><code>TrendDecomposition.expSmoothing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">expSmoothing(y :: Vector, λ :: Real; startValue::Bool = true, v_0::Real = 0.0)</code></pre><p>Simple exponential smoothing with smoothing factor λ. If startValue equals true, v_0 will be used as initial value, otherwise the first element of y (y[1]) will be selected as starting value. Using y[1] as starting value will result in a different mathematical function.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L5-L12">source</a></section></details></article><h2 id="Holt&#39;s-procedure"><a class="docs-heading-anchor" href="#Holt&#39;s-procedure">Holt&#39;s procedure</a><a id="Holt&#39;s-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Holt&#39;s-procedure" title="Permalink"></a></h2><p>In order to account for a trend and to make forecasts a local slope <span>$b_t$</span> was introduced by Holt (1957)<sup class="footnote-reference"><a id="citeref-Holt57" href="#footnote-Holt57" class="footnote-ref">[Holt57]</a><span class="footnote-preview" id="fn-Holt57"></span></sup> , which is updated each period t.  As for most time series it is unrealistic to assume that a linear line is to presist much long into the future, a damping factor <span>$\varphi$</span> (\varphi) can be used and is set between <span>$0 &lt; \varphi &lt; 1$</span>.</p><p class="math-container">\[	\begin{aligned}
    l_t &amp;= \lambda_1 * y_t + (1-\lambda_1) * (l_{t-1} + \varphi b_{t-1}) \\
	b_t &amp;= \lambda_2 * (l_{t} + l_{t-1}) + (1-\lambda_2) * \varphi b_{t-1} \\
	\^y_t &amp;= l_{t-1} + \varphi b_{t -1}
	\end{aligned}\]</p><article><details class="docstring" open="true"><summary id="TrendDecomposition.holtLinear-Tuple{Vector, Real, Real}"><a class="docstring-binding" href="#TrendDecomposition.holtLinear-Tuple{Vector, Real, Real}"><code>TrendDecomposition.holtLinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">holtLinear(y :: Vector, λ₁ :: Real, λ₂ :: Real;
                startValues::Tuple=(), h::Int = 0, φ::Real = 1.0)</code></pre><p>Holt&#39;s linear trend method with smoothing factors λ₁ (level) and λ₂ (slope) and damping factor φ (\varphi) given vector y (N x 1) and h forecast periods.</p><p>Start values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.</p><p>Returns a tuple with (f, D), where f is a ((N+h) x 1) vector with the forecast values and D is a (N x 2) matrix with the level and slope as columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L122-L135">source</a></section></details></article><h2 id="Double-exponential-smoothing"><a class="docs-heading-anchor" href="#Double-exponential-smoothing">Double exponential smoothing</a><a id="Double-exponential-smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Double-exponential-smoothing" title="Permalink"></a></h2><p>By using the above introduced residual or error term <span>$\^u_t$</span>, the level <span>$l_t$</span> and slope <span>$b_t$</span> parameters can be estimated as:</p><p class="math-container">\[	\begin{aligned}
	l_t &amp;= l_{t-1} + \varphi b_{t-1} + (1 - \lambda^2) \^u_t \\
	b_t &amp;= \varphi b_{t-1} + (1 - \lambda)^{2} \^u_t  \\
	\^y_t &amp;= l_{t-1} + \varphi b_{t -1}
	\end{aligned}\]</p><p>This recursion is known as double exponential smoothing and also named after R.G. Brown (1963)<sup class="footnote-reference"><a id="citeref-Brown63" href="#footnote-Brown63" class="footnote-ref">[Brown63]</a><span class="footnote-preview" id="fn-Brown63"></span></sup> and can been seen as a special case of Holt&#39;s procedure by setting <span>$\lambda_0 = 1 - \lambda^2$</span> and <span>$\lambda_1 = \frac{1 - \lambda}{1 + \lambda}$</span>.</p><article><details class="docstring" open="true"><summary id="TrendDecomposition.brownLinear-Tuple{Vector, Real}"><a class="docstring-binding" href="#TrendDecomposition.brownLinear-Tuple{Vector, Real}"><code>TrendDecomposition.brownLinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">brownLinear(y :: Vector, λ :: Real; h::Int = 0, startValues::Tuple=(), φ::Real = 1.0)</code></pre><p>Double exponential smoothing with smoothing factor λ and damping factor φ (\varphi) given vector y (N x 1) and h forecast periods.</p><p>Start values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.</p><p>Returns a tuple with (f, D), where f is a (N+h) x 1 vector with the forecast values and D is a (N x 2) matrix with the level and slope as columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L29-L41">source</a></section></details></article><h2 id="Holt-Winters-forecasting"><a class="docs-heading-anchor" href="#Holt-Winters-forecasting">Holt-Winters forecasting</a><a id="Holt-Winters-forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Holt-Winters-forecasting" title="Permalink"></a></h2><p>In addition a seasonal component <span>$S_t$</span> can be modeled for number of seasons s. This introduces an additional equation for <span>$S_t$</span>: </p><p class="math-container">\[	\begin{aligned}
    l_t &amp;= \lambda_1 * (y_t - S_{t-s}) + (1-\lambda_1) * (l_{t-1} + \varphi b_{t-1}) \\
	b_t &amp;= \lambda_2 * (l_{t} + l_{t-1}) + (1-\lambda_2) * b_{t-1} \varphi \\
    S_t &amp;= \lambda_3 * (y_t + l_t) + (1-\lambda_3) * S_{t-s} \\
	\^y_{T+h} &amp;= l_{T} + b_{T} (\varphi + \varphi^2 +...+ \varphi^h) + S_{T+h-s}
	\end{aligned}\]</p><p>As for the t=1,...,s first values there exists no previous values for <span>$S_t$</span>,  they have to be estimated before starting the recursion computation.  <a href="../moving/#TrendDecomposition.maSeason"><code>maSeason</code></a> will be used for the first <span>$2*s$</span> values of the detrended time series.  Similar for forecast horizions h &gt; s, the same latest s estimated season components from time periods (T-s-1) to T have to be used over again.</p><article><details class="docstring" open="true"><summary id="TrendDecomposition.holtWinters-Tuple{Vector, Real, Real, Real, Int64}"><a class="docstring-binding" href="#TrendDecomposition.holtWinters-Tuple{Vector, Real, Real, Real, Int64}"><code>TrendDecomposition.holtWinters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">holtWinters(y :: Vector, λ₁ :: Real, λ₂ :: Real, λ₃ :: Real, s::Int;
                 startValues::Tuple=(), h::Int = 0, model=:add, φ::Real = 1.0)</code></pre><p>Holt-Winters method with smoothing factors λ₁ (level), λ₂ (slope) and λ₃ (season) and damping factor φ (\varphi) given vector y (N x 1) and h forecast periods.</p><p>The number of seasons s has to be specified (s&gt;0), else use TrendDecomposition.holtLinear. </p><p>Start values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.</p><p>Returns a tuple with (f, D), where f is a ((N+h) x 1) vector with the forecast values and D is a (N x 3) matrix with the level, slope, season values as columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L225-L240">source</a></section></details></article><h3 id="General-behavior-of-holtLinear,-brownLinear-and-holtWinters"><a class="docs-heading-anchor" href="#General-behavior-of-holtLinear,-brownLinear-and-holtWinters">General behavior of holtLinear, brownLinear and holtWinters</a><a id="General-behavior-of-holtLinear,-brownLinear-and-holtWinters-1"></a><a class="docs-heading-anchor-permalink" href="#General-behavior-of-holtLinear,-brownLinear-and-holtWinters" title="Permalink"></a></h3><p>By default <span>$\varphi=1$</span> in <code>holtLinear</code>, <code>brownLinear</code> and <code>holtWinters</code> method implementations, so that no damping takes place unless explicitly set. If no start values <span>$(l_0, b_0)$</span> are given for the level and slope parameters, the recursion can only start in time period 3, as start values will be calculated using the first two observations as <span>$l_2 = y_2$</span> and <span>$b_2 = y_2 - y_1$</span>.  Given the input vector y has length N, the output vector f is still has the length (N+h), as well as the output matrix D still has N rows. The not available values for periods 1 and 2 are put as NaN<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> to avoid using a Union{T, Missing} type in julia, which would make a type recast necessary. </p><h2 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h2><p>There is no general solution to the problem of selecting the optimal parameter values for any of the above introduced models. The <code>Optim.jl</code> package provides box constrained algorithms to find the parameters that minimize the sum of squres error, this is equivalent to using a mean squared error function as loss function. But because of the complexity involved it is not guarannteed that a global minimum will be found, but rather a local minimum. </p><p>By using this procedure, the internal consistency, which is in favour of achieving the best fit for a decomposition, is choosen over external validity, which the preferred criterium when making forecasts.  But the best approach for extensive forecasting is to use a framework or julia package which generally supports cross-validation for evaluating any forecast model with a horizon h greater than 1. </p><h3 id="How-to-get-the-optimized-parameters"><a class="docs-heading-anchor" href="#How-to-get-the-optimized-parameters">How to get the optimized parameters</a><a id="How-to-get-the-optimized-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-get-the-optimized-parameters" title="Permalink"></a></h3><p>By using multiple dispatch the above introduced functions can basically be used without specifying any smoothing parameters for them to be estimated automatically. The current implementation only allows for all smoothing parameters to be omitted altogether.  In addition, the damping parameter can also be estimated, which is the default, otherwise it has to be manually set e.g. <span>$\varphi = 1.0$</span> for it to have no impact.</p><p>As an example, instead of setting the parameters manually like in <code>holtWinters(data, 0.9, 0.9, 0.9, seasons)</code>, all smoothing parameters must be droped for the automatic optimization of the smoothing and dumping parameters and the function simplifies to <code>holtWinters(data, seasons)</code>.</p><p>A named tuple is returned and the estimated parameters can be accessed in two ways: </p><pre><code class="language-julia hljs">	f, D, p = holtWinters(data, seasons, φ=1.0)</code></pre><pre><code class="language-julia hljs">	res = holtWinters(data, seasons, φ=1.0)
	
	f = res.forecast
	D = res.model
	p = res.parameters
	</code></pre><h3 id="Methods-for-automatic-parameter-optimization"><a class="docs-heading-anchor" href="#Methods-for-automatic-parameter-optimization">Methods for automatic parameter optimization</a><a id="Methods-for-automatic-parameter-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-automatic-parameter-optimization" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="TrendDecomposition.holtWinters-Tuple{Vector, Int64}"><a class="docstring-binding" href="#TrendDecomposition.holtWinters-Tuple{Vector, Int64}"><code>TrendDecomposition.holtWinters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">holtWinters(y :: Vector, s::Int;
                 startValues::Tuple=(), h::Int = 0, model=:add, φ::Union{Real, Nothing} = nothing)</code></pre><p>Holt-Winters method with damping factor φ (\varphi) given vector y (N x 1) and h forecast periods.</p><p>The number of seasons s has to be specified (s&gt;0), else use TrendDecomposition.holtLinear. </p><p>The smoothing parameters are estimated by minimizing the loss function using Optim.jl. For φ equal nothing, its value is also determined by the optimization algorithm.</p><p>Start values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.</p><p>Returns a tuple with (f, D, p), where f is a ((N+h) x 1) vector with the forecast values and D is a (N x 3) matrix with the level, slope, season values as columns, and p is a vector containing the estimated parameter(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L322-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrendDecomposition.holtLinear-Tuple{Vector}"><a class="docstring-binding" href="#TrendDecomposition.holtLinear-Tuple{Vector}"><code>TrendDecomposition.holtLinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">holtLinear(y :: Vector;
                startValues::Tuple=(), h::Int = 0, φ::Union{Real, Nothing} = nothing)</code></pre><p>Holt&#39;s linear trend method with damping factor φ (\varphi) given vector y (N x 1) and h forecast periods.</p><p>The smoothing parameters are estimated by minimizing the loss function using Optim.jl. For φ equal nothing, its value is also determined by the optimization algorithm.</p><p>Start values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.</p><p>Returns a tuple with (f, D, p), where f is a ((N+h) x 1) vector with the forecast values and D is a (N x 2) matrix with the level and slope as columns, and p is a vector containing the estimated parameter(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L177-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrendDecomposition.brownLinear-Tuple{Vector}"><a class="docstring-binding" href="#TrendDecomposition.brownLinear-Tuple{Vector}"><code>TrendDecomposition.brownLinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">brownLinear(y :: Vector; h::Int = 0, startValues::Tuple=(), φ::Union{Real, Nothing} = nothing)</code></pre><p>Double exponential smoothing with damping factor φ (\varphi) given vector y (N x 1) and h forecast periods. The smoothing parameter λ is estimated by minimizing the loss function using Optim.jl. For φ equal nothing, its value is also determined by the optimization algorithm.</p><p>Start values of level and slope can be given as tuple (l₀, b₀), otherwise output values start at period 3.</p><p>Returns a tuple with (f, D, p), where f is a (N+h) x 1 vector with the forecast values and D is a (N x 2) matrix with the level and slope as columns, and p is a vector containing the estimated parameter(s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdBrinkmann/TrendDecomposition.jl/blob/fc295a7f5c0d03cc76370610c0d58e17c177c16b/src/expSmoothing.jl#L80-L94">source</a></section></details></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Winters60"><a class="tag is-link" href="#citeref-Winters60">Winters60</a><blockquote><p>Winters, P.R. (1960). Forecasting sales by exponentially weighted moving averages. Management Science 6: 324-42</p></blockquote></li><li class="footnote" id="footnote-Holt57"><a class="tag is-link" href="#citeref-Holt57">Holt57</a><blockquote><p>Holt, Charles C. (1957). &quot;Forecasting Trends and Seasonal by Exponentially Weighted Averages&quot;. Office of Naval Research Memorandum</p></blockquote></li><li class="footnote" id="footnote-Brown63"><a class="tag is-link" href="#citeref-Brown63">Brown63</a><blockquote><p>Brown, R.G. (1963). Smoothing, Forecasting and Prediction. Englewood Cliffs: Prentice Hall.</p></blockquote></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><blockquote><p>Be aware that Julia follows the IEEE 754 standard for floating-point values. The operation <code>NaN == NaN</code> will result in false, which makes e.g. comparisons  of vectors very tricky.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../penalized/">« Penalized Smoothing</a><a class="docs-footer-nextpage" href="../misc/">Miscellaneous »</a><div class="flexbox-break"></div><p class="footer-message">© 2025 Stefan D. Brinkmann</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 23:02">Tuesday 13 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
